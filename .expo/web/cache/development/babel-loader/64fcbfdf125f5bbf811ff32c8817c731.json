{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction e(e, t, n, r, i, a, s) {\n  try {\n    var o = e[a](s),\n        c = o.value;\n  } catch (e) {\n    return void n(e);\n  }\n\n  o.done ? t(c) : Promise.resolve(c).then(r, i);\n}\n\nfunction t(e, t) {\n  if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction n(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n  }\n}\n\nfunction r(e, t, n) {\n  return t in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\n\nfunction i(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = null != arguments[t] ? arguments[t] : {},\n        i = Object.keys(n);\n    \"function\" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (e) {\n      return Object.getOwnPropertyDescriptor(n, e).enumerable;\n    }))), i.forEach(function (t) {\n      r(e, t, n[t]);\n    });\n  }\n\n  return e;\n}\n\nfunction a(e, t) {\n  if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, {\n    constructor: {\n      value: e,\n      writable: !0,\n      configurable: !0\n    }\n  }), t && o(e, t);\n}\n\nfunction s(e) {\n  return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n    return e.__proto__ || Object.getPrototypeOf(e);\n  })(e);\n}\n\nfunction o(e, t) {\n  return (o = Object.setPrototypeOf || function (e, t) {\n    return e.__proto__ = t, e;\n  })(e, t);\n}\n\nfunction c(e, t, n) {\n  return (c = function () {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n\n    try {\n      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }() ? Reflect.construct : function (e, t, n) {\n    var r = [null];\n    r.push.apply(r, t);\n    var i = new (Function.bind.apply(e, r))();\n    return n && o(i, n.prototype), i;\n  }).apply(null, arguments);\n}\n\nfunction u(e) {\n  var t = \"function\" == typeof Map ? new Map() : void 0;\n  return (u = function u(e) {\n    if (null === e || (n = e, -1 === Function.toString.call(n).indexOf(\"[native code]\"))) return e;\n    var n;\n    if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== t) {\n      if (t.has(e)) return t.get(e);\n      t.set(e, r);\n    }\n\n    function r() {\n      return c(e, arguments, s(this).constructor);\n    }\n\n    return r.prototype = Object.create(e.prototype, {\n      constructor: {\n        value: r,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), o(r, e);\n  })(e);\n}\n\nfunction h(e, t) {\n  return !t || \"object\" != typeof t && \"function\" != typeof t ? function (e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }(e) : t;\n}\n\nvar l = function (e) {\n  function n(e) {\n    var r;\n    return t(this, n), (r = h(this, s(n).call(this, \"Not Found! Params: \".concat(e)))).name = \"NotFoundError\", r.stack = new Error().stack, r;\n  }\n\n  return a(n, u(Error)), n;\n}(),\n    f = function (e) {\n  function n(e) {\n    var r;\n    return t(this, n), (r = h(this, s(n).call(this, \"Expired! Params: \".concat(e)))).name = \"ExpiredError\", r.stack = new Error().stack, r;\n  }\n\n  return a(n, u(Error)), n;\n}();\n\nexport default (function () {\n  function r() {\n    var e = this,\n        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n    if (t(this, r), this._SIZE = n.size || 1e3, this.sync = n.sync || {}, this.defaultExpires = void 0 !== n.defaultExpires ? n.defaultExpires : 864e5, this.enableCache = !1 !== n.enableCache, this._s = n.storageBackend || null, this._innerVersion = 11, this.cache = {}, this._s && this._s.setItem) try {\n      var i = this._s.setItem(\"__react_native_storage_test\", \"test\");\n\n      this.isPromise = !(!i || !i.then);\n    } catch (e) {\n      throw console.warn(e), delete this._s, e;\n    } else console.warn(\"Data would be lost after reload cause there is no storageBackend specified!\\n      \\nEither use localStorage(for web) or AsyncStorage(for React Native) as a storageBackend.\");\n    this._mapPromise = this.getItem(\"map\").then(function (t) {\n      e._m = e._checkMap(t && JSON.parse(t) || {});\n    });\n  }\n\n  var a, s, o, c, u;\n  return a = r, (s = [{\n    key: \"getItem\",\n    value: function value(e) {\n      return this._s ? this.isPromise ? this._s.getItem(e) : Promise.resolve(this._s.getItem(e)) : Promise.resolve();\n    }\n  }, {\n    key: \"setItem\",\n    value: function value(e, t) {\n      return this._s ? this.isPromise ? this._s.setItem(e, t) : Promise.resolve(this._s.setItem(e, t)) : Promise.resolve();\n    }\n  }, {\n    key: \"removeItem\",\n    value: function value(e) {\n      return this._s ? this.isPromise ? this._s.removeItem(e) : Promise.resolve(this._s.removeItem(e)) : Promise.resolve();\n    }\n  }, {\n    key: \"_initMap\",\n    value: function value() {\n      return {\n        innerVersion: this._innerVersion,\n        index: 0,\n        __keys__: {}\n      };\n    }\n  }, {\n    key: \"_checkMap\",\n    value: function value(e) {\n      return e && e.innerVersion && e.innerVersion === this._innerVersion ? e : this._initMap();\n    }\n  }, {\n    key: \"_getId\",\n    value: function value(e, t) {\n      return e + \"_\" + t;\n    }\n  }, {\n    key: \"_saveToMap\",\n    value: function value(e) {\n      var t = e.key,\n          n = e.id,\n          r = e.data,\n          i = this._getId(t, n),\n          a = this._m;\n\n      if (void 0 !== a[i]) return this.enableCache && (this.cache[i] = JSON.parse(r)), this.setItem(\"map_\" + a[i], r);\n\n      if (void 0 !== a[a.index]) {\n        var s = a[a.index],\n            o = s.split(\"_\");\n        delete a[s], this._removeIdInKey(o[0], o[1]), this.enableCache && delete this.cache[s];\n      }\n\n      if (a[i] = a.index, a[a.index] = i, a.__keys__[t] = a.__keys__[t] || [], a.__keys__[t].push(n), this.enableCache) {\n        var c = JSON.parse(r);\n        this.cache[i] = c;\n      }\n\n      var u = a.index;\n      ++a.index === this._SIZE && (a.index = 0), this.setItem(\"map_\" + u, r), this.setItem(\"map\", JSON.stringify(a));\n    }\n  }, {\n    key: \"save\",\n    value: function value(e) {\n      var t = this,\n          n = e.key,\n          r = e.id,\n          i = e.data,\n          a = e.rawData,\n          s = e.expires,\n          o = void 0 === s ? this.defaultExpires : s;\n      -1 !== n.toString().indexOf(\"_\") && console.error('Please do not use \"_\" in key!');\n      var c = {\n        rawData: i\n      };\n\n      if (void 0 === i) {\n        if (void 0 === a) return void console.error('\"data\" is required in save()!');\n        console.warn('\"rawData\" is deprecated, please use \"data\" instead!'), c.rawData = a;\n      }\n\n      var u = Date.now();\n\n      if (null !== o && (c.expires = u + o), c = JSON.stringify(c), void 0 === r) {\n        if (this.enableCache) {\n          var h = JSON.parse(c);\n          this.cache[n] = h;\n        }\n\n        return this.setItem(n, c);\n      }\n\n      return -1 !== r.toString().indexOf(\"_\") && console.error('Please do not use \"_\" in id!'), this._mapPromise.then(function () {\n        return t._saveToMap({\n          key: n,\n          id: r,\n          data: c\n        });\n      });\n    }\n  }, {\n    key: \"getBatchData\",\n    value: function value(e) {\n      var t = this;\n      return Promise.all(e.map(function (e) {\n        return t.load(e);\n      }));\n    }\n  }, {\n    key: \"getBatchDataWithIds\",\n    value: (c = _regeneratorRuntime.mark(function e(t) {\n      var n,\n          r,\n          i,\n          a,\n          s,\n          o,\n          c,\n          u,\n          h = this;\n      return _regeneratorRuntime.wrap(function (e) {\n        for (;;) {\n          switch (e.prev = e.next) {\n            case 0:\n              return n = t.key, r = t.ids, i = t.syncInBackground, a = t.syncParams, s = r.map(function (e) {\n                return h.load({\n                  key: n,\n                  id: e,\n                  syncInBackground: i,\n                  autoSync: !1,\n                  batched: !0\n                });\n              }), e.next = 4, Promise.all(s);\n\n            case 4:\n              if (o = e.sent, c = [], o.forEach(function (e) {\n                void 0 !== e.syncId && c.push(e.syncId);\n              }), !c.length) {\n                e.next = 14;\n                break;\n              }\n\n              return e.next = 10, this.sync[n]({\n                id: c,\n                syncParams: a\n              });\n\n            case 10:\n              return u = e.sent, e.abrupt(\"return\", o.map(function (e) {\n                return e.syncId ? u.shift() : e;\n              }));\n\n            case 14:\n              return e.abrupt(\"return\", o);\n\n            case 15:\n            case \"end\":\n              return e.stop();\n          }\n        }\n      }, e, this);\n    }), u = function u() {\n      var t = this,\n          n = arguments;\n      return new Promise(function (r, i) {\n        var a = c.apply(t, n);\n\n        function s(t) {\n          e(a, r, i, s, o, \"next\", t);\n        }\n\n        function o(t) {\n          e(a, r, i, s, o, \"throw\", t);\n        }\n\n        s(void 0);\n      });\n    }, function (e) {\n      return u.apply(this, arguments);\n    })\n  }, {\n    key: \"_lookupGlobalItem\",\n    value: function value(e) {\n      var t = this,\n          n = e.key;\n      return this.enableCache && void 0 !== this.cache[n] ? this._loadGlobalItem(i({\n        ret: this.cache[n]\n      }, e)) : this.getItem(n).then(function (n) {\n        return t._loadGlobalItem(i({\n          ret: n\n        }, e));\n      });\n    }\n  }, {\n    key: \"_loadGlobalItem\",\n    value: function value(e) {\n      var t = e.key,\n          n = e.ret,\n          r = e.autoSync,\n          i = e.syncInBackground,\n          a = e.syncParams;\n\n      if (null == n) {\n        if (r && this.sync[t]) return this.sync[t]({\n          syncParams: a\n        });\n        throw new l(JSON.stringify(e));\n      }\n\n      \"string\" == typeof n && (n = JSON.parse(n), this.enableCache && (this.cache[t] = n));\n      var s = Date.now();\n\n      if (n.expires < s) {\n        if (r && this.sync[t]) {\n          if (i) {\n            try {\n              this.sync[t]({\n                syncParams: a,\n                syncInBackground: i\n              });\n            } catch (e) {}\n\n            return n.rawData;\n          }\n\n          return this.sync[t]({\n            syncParams: a,\n            syncInBackground: i\n          });\n        }\n\n        throw new f(JSON.stringify(e));\n      }\n\n      return n.rawData;\n    }\n  }, {\n    key: \"_noItemFound\",\n    value: function value(e) {\n      var t = e.key,\n          n = e.id,\n          r = e.autoSync,\n          i = e.syncParams;\n      if (this.sync[t]) return r ? this.sync[t]({\n        id: n,\n        syncParams: i\n      }) : {\n        syncId: n\n      };\n      throw new l(JSON.stringify(e));\n    }\n  }, {\n    key: \"_loadMapItem\",\n    value: function value(e) {\n      var t = e.ret,\n          n = e.key,\n          r = e.id,\n          i = e.autoSync,\n          a = e.batched,\n          s = e.syncInBackground,\n          o = e.syncParams;\n      if (null == t) return this._noItemFound(e);\n\n      if (\"string\" == typeof t) {\n        t = JSON.parse(t);\n\n        var c = e.key,\n            u = e.id,\n            h = this._getId(c, u);\n\n        this.enableCache && (this.cache[h] = t);\n      }\n\n      var l = Date.now();\n\n      if (t.expires < l) {\n        if (i && this.sync[n]) {\n          if (s) {\n            try {\n              this.sync[n]({\n                id: r,\n                syncParams: o,\n                syncInBackground: s\n              });\n            } catch (e) {}\n\n            return t.rawData;\n          }\n\n          return this.sync[n]({\n            id: r,\n            syncParams: o,\n            syncInBackground: s\n          });\n        }\n\n        if (a) return {\n          syncId: r\n        };\n        throw new f(JSON.stringify(e));\n      }\n\n      return t.rawData;\n    }\n  }, {\n    key: \"_lookUpInMap\",\n    value: function value(e) {\n      var t,\n          n = this,\n          r = this._m,\n          a = e.key,\n          s = e.id,\n          o = this._getId(a, s);\n\n      return this.enableCache && this.cache[o] ? (t = this.cache[o], this._loadMapItem(i({\n        ret: t\n      }, e))) : void 0 !== r[o] ? this.getItem(\"map_\" + r[o]).then(function (t) {\n        return n._loadMapItem(i({\n          ret: t\n        }, e));\n      }) : this._noItemFound(i({\n        ret: t\n      }, e));\n    }\n  }, {\n    key: \"remove\",\n    value: function value(e) {\n      var t = this;\n      return this._mapPromise.then(function () {\n        var n = t._m,\n            r = e.key,\n            i = e.id;\n        if (void 0 === i) return t.enableCache && t.cache[r] && delete t.cache[r], t.removeItem(r);\n\n        var a = t._getId(r, i);\n\n        if (void 0 !== n[a]) {\n          t.enableCache && t.cache[a] && delete t.cache[a], t._removeIdInKey(r, i);\n          var s = n[a];\n          return delete n[a], t.setItem(\"map\", JSON.stringify(n)), t.removeItem(\"map_\" + s);\n        }\n      });\n    }\n  }, {\n    key: \"_removeIdInKey\",\n    value: function value(e, t) {\n      var n = (this._m.__keys__[e] || []).indexOf(t);\n      -1 !== n && this._m.__keys__[e].splice(n, 1);\n    }\n  }, {\n    key: \"load\",\n    value: function value(e) {\n      var t = this,\n          n = e.key,\n          r = e.id,\n          i = e.autoSync,\n          a = void 0 === i || i,\n          s = e.syncInBackground,\n          o = void 0 === s || s,\n          c = e.syncParams,\n          u = e.batched;\n      return this._mapPromise.then(function () {\n        return void 0 === r ? t._lookupGlobalItem({\n          key: n,\n          autoSync: a,\n          syncInBackground: o,\n          syncParams: c\n        }) : t._lookUpInMap({\n          key: n,\n          id: r,\n          autoSync: a,\n          syncInBackground: o,\n          batched: u,\n          syncParams: c\n        });\n      });\n    }\n  }, {\n    key: \"clearAll\",\n    value: function value() {\n      this._s.clear && this._s.clear(), this._m = this._initMap();\n    }\n  }, {\n    key: \"clearMap\",\n    value: function value() {\n      var e = this;\n      return this.removeItem(\"map\").then(function () {\n        e.cache = {}, e._m = e._initMap();\n      });\n    }\n  }, {\n    key: \"clearMapForKey\",\n    value: function value(e) {\n      var t = this;\n      return this._mapPromise.then(function () {\n        var n = (t._m.__keys__[e] || []).map(function (n) {\n          return t.remove({\n            key: e,\n            id: n\n          });\n        });\n        return Promise.all(n);\n      });\n    }\n  }, {\n    key: \"getIdsForKey\",\n    value: function value(e) {\n      var t = this;\n      return this._mapPromise.then(function () {\n        return t._m.__keys__[e] || [];\n      });\n    }\n  }, {\n    key: \"getAllDataForKey\",\n    value: function value(e, t) {\n      var n = this;\n      return t = Object.assign({\n        syncInBackground: !0\n      }, t), this.getIdsForKey(e).then(function (r) {\n        var i = r.map(function (n) {\n          return {\n            key: e,\n            id: n,\n            syncInBackground: t.syncInBackground\n          };\n        });\n        return n.getBatchData(i);\n      });\n    }\n  }]) && n(a.prototype, s), o && n(a, o), r;\n})();","map":{"version":3,"mappings":"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","names":["NotFoundError","message","name","r","stack","Error","ExpiredError","options","_SIZE","size","sync","defaultExpires","undefined","enableCache","_s","storageBackend","_innerVersion","cache","this","setItem","promiseTest","isPromise","then","e","console","warn","_mapPromise","getItem","_this","_m","_checkMap","map","JSON","parse","key","value","Promise","resolve","removeItem","innerVersion","index","__keys__","_initMap","id","params","data","newId","_getId","m","oldId","splitOldId","split","_removeIdInKey","push","cacheData","currentIndex","stringify","rawData","expires","toString","indexOf","error","dataToSave","now","Date","_this2","_saveToMap","querys","all","query","_this3","load","ids","syncInBackground","syncParams","tasks","_this4","autoSync","batched","results","missingIds","forEach","syncId","length","syncData","shift","_loadGlobalItem","ret","_this5","_noItemFound","_loadMapItem","_this6","_this7","idTobeDeleted","indexTobeRemoved","splice","_this8","_lookupGlobalItem","_lookUpInMap","clear","_this9","_this10","remove","_this11","Object","assign","getIdsForKey","_this12","getBatchData"],"sources":["../src/error.js","../src/storage.js"],"sourcesContent":["/**\n * Created by sunny on 9/1/16.\n */\n\nexport class NotFoundError extends Error {\n  constructor(message) {\n    super(`Not Found! Params: ${message}`);\n    this.name = 'NotFoundError';\n    this.stack = new Error().stack; // Optional\n  }\n}\n// NotFoundError.prototype = Object.create(Error.prototype);\n\nexport class ExpiredError extends Error {\n  constructor(message) {\n    super(`Expired! Params: ${message}`);\n    this.name = 'ExpiredError';\n    this.stack = new Error().stack; // Optional\n  }\n}\n// ExpiredError.prototype = Object.create(Error.prototype);\n","/*\n *  local storage(web/react native) wrapper\n *  sunnylqm\n */\nimport { NotFoundError, ExpiredError } from './error';\n\nexport default class Storage {\n  constructor(options = {}) {\n    this._SIZE = options.size || 1000; // maximum capacity\n    this.sync = options.sync || {}; // remote sync method\n    this.defaultExpires = options.defaultExpires !== undefined ? options.defaultExpires : 1000 * 3600 * 24;\n    this.enableCache = options.enableCache !== false;\n    this._s = options.storageBackend || null;\n    this._innerVersion = 11;\n    this.cache = {};\n\n    if (this._s && this._s.setItem) {\n      try {\n        var promiseTest = this._s.setItem('__react_native_storage_test', 'test');\n        this.isPromise = !!(promiseTest && promiseTest.then);\n      } catch (e) {\n        console.warn(e);\n        delete this._s;\n        throw e;\n      }\n    } else {\n      console.warn(`Data would be lost after reload cause there is no storageBackend specified!\n      \\nEither use localStorage(for web) or AsyncStorage(for React Native) as a storageBackend.`);\n    }\n\n    this._mapPromise = this.getItem('map').then(map => {\n      this._m = this._checkMap((map && JSON.parse(map)) || {});\n    });\n  }\n  getItem(key) {\n    return this._s\n      ? this.isPromise\n        ? this._s.getItem(key)\n        : Promise.resolve(this._s.getItem(key))\n      : Promise.resolve();\n  }\n  setItem(key, value) {\n    return this._s\n      ? this.isPromise\n        ? this._s.setItem(key, value)\n        : Promise.resolve(this._s.setItem(key, value))\n      : Promise.resolve();\n  }\n  removeItem(key) {\n    return this._s\n      ? this.isPromise\n        ? this._s.removeItem(key)\n        : Promise.resolve(this._s.removeItem(key))\n      : Promise.resolve();\n  }\n  _initMap() {\n    return {\n      innerVersion: this._innerVersion,\n      index: 0,\n      __keys__: {},\n    };\n  }\n  _checkMap(map) {\n    if (map && map.innerVersion && map.innerVersion === this._innerVersion) {\n      return map;\n    } else {\n      return this._initMap();\n    }\n  }\n  _getId(key, id) {\n    return key + '_' + id;\n  }\n  _saveToMap(params) {\n    let { key, id, data } = params,\n      newId = this._getId(key, id),\n      m = this._m;\n    if (m[newId] !== undefined) {\n      // update existing data\n      if (this.enableCache) this.cache[newId] = JSON.parse(data);\n      return this.setItem('map_' + m[newId], data);\n    }\n    if (m[m.index] !== undefined) {\n      // loop over, delete old data\n      let oldId = m[m.index];\n      let splitOldId = oldId.split('_');\n      delete m[oldId];\n      this._removeIdInKey(splitOldId[0], splitOldId[1]);\n      if (this.enableCache) {\n        delete this.cache[oldId];\n      }\n    }\n    m[newId] = m.index;\n    m[m.index] = newId;\n\n    m.__keys__[key] = m.__keys__[key] || [];\n    m.__keys__[key].push(id);\n\n    if (this.enableCache) {\n      const cacheData = JSON.parse(data);\n      this.cache[newId] = cacheData;\n    }\n    let currentIndex = m.index;\n    if (++m.index === this._SIZE) {\n      m.index = 0;\n    }\n    this.setItem('map_' + currentIndex, data);\n    this.setItem('map', JSON.stringify(m));\n  }\n  save(params) {\n    const { key, id, data, rawData, expires = this.defaultExpires } = params;\n    if (key.toString().indexOf('_') !== -1) {\n      console.error('Please do not use \"_\" in key!');\n    }\n    let dataToSave = { rawData: data };\n    if (data === undefined) {\n      if (rawData !== undefined) {\n        console.warn('\"rawData\" is deprecated, please use \"data\" instead!');\n        dataToSave.rawData = rawData;\n      } else {\n        console.error('\"data\" is required in save()!');\n        return;\n      }\n    }\n    let now = Date.now();\n    if (expires !== null) {\n      dataToSave.expires = now + expires;\n    }\n    dataToSave = JSON.stringify(dataToSave);\n    if (id === undefined) {\n      if (this.enableCache) {\n        const cacheData = JSON.parse(dataToSave);\n        this.cache[key] = cacheData;\n      }\n      return this.setItem(key, dataToSave);\n    } else {\n      if (id.toString().indexOf('_') !== -1) {\n        console.error('Please do not use \"_\" in id!');\n      }\n      return this._mapPromise.then(() =>\n        this._saveToMap({\n          key,\n          id,\n          data: dataToSave,\n        }),\n      );\n    }\n  }\n  getBatchData(querys) {\n    return Promise.all(querys.map(query => this.load(query)));\n  }\n  async getBatchDataWithIds(params) {\n    let { key, ids, syncInBackground, syncParams } = params;\n    const tasks = ids.map(id =>\n      this.load({\n        key,\n        id,\n        syncInBackground,\n        autoSync: false,\n        batched: true,\n      }),\n    );\n    const results = await Promise.all(tasks);\n    const missingIds = [];\n    results.forEach(value => {\n      if (value.syncId !== undefined) {\n        missingIds.push(value.syncId);\n      }\n    });\n    if (missingIds.length) {\n      const syncData = await this.sync[key]({\n        id: missingIds,\n        syncParams,\n      });\n      return results.map(value => {\n        return value.syncId ? syncData.shift() : value;\n      });\n    } else {\n      return results;\n    }\n  }\n  _lookupGlobalItem(params) {\n    const { key } = params;\n    if (this.enableCache && this.cache[key] !== undefined) {\n      return this._loadGlobalItem({ ret: this.cache[key], ...params });\n    }\n    return this.getItem(key).then(ret => this._loadGlobalItem({ ret, ...params }));\n  }\n  _loadGlobalItem(params) {\n    let { key, ret, autoSync, syncInBackground, syncParams } = params;\n    if (ret === null || ret === undefined) {\n      if (autoSync && this.sync[key]) {\n        return this.sync[key]({ syncParams });\n      }\n      throw new NotFoundError(JSON.stringify(params));\n    }\n    if (typeof ret === 'string') {\n      ret = JSON.parse(ret);\n      if (this.enableCache) {\n        this.cache[key] = ret;\n      }\n    }\n    let now = Date.now();\n    if (ret.expires < now) {\n      if (autoSync && this.sync[key]) {\n        if (syncInBackground) {\n          try {\n            this.sync[key]({ syncParams, syncInBackground });\n          } catch (e) {\n            // avoid uncaught exception\n          }\n          return ret.rawData;\n        }\n        return this.sync[key]({ syncParams, syncInBackground });\n      }\n      throw new ExpiredError(JSON.stringify(params));\n    }\n    return ret.rawData;\n  }\n  _noItemFound(params) {\n    let { key, id, autoSync, syncParams } = params;\n    if (this.sync[key]) {\n      if (autoSync) {\n        return this.sync[key]({ id, syncParams });\n      }\n      return { syncId: id };\n    }\n    throw new NotFoundError(JSON.stringify(params));\n  }\n  _loadMapItem(params) {\n    let { ret, key, id, autoSync, batched, syncInBackground, syncParams } = params;\n    if (ret === null || ret === undefined) {\n      return this._noItemFound(params);\n    }\n    if (typeof ret === 'string') {\n      ret = JSON.parse(ret);\n      const { key, id } = params;\n      const newId = this._getId(key, id);\n      if (this.enableCache) {\n        this.cache[newId] = ret;\n      }\n    }\n    let now = Date.now();\n    if (ret.expires < now) {\n      if (autoSync && this.sync[key]) {\n        if (syncInBackground) {\n          try {\n            this.sync[key]({ id, syncParams, syncInBackground });\n          } catch (e) {\n            // avoid uncaught exception\n          }\n          return ret.rawData;\n        }\n        return this.sync[key]({ id, syncParams, syncInBackground });\n      }\n      if (batched) {\n        return { syncId: id };\n      }\n      throw new ExpiredError(JSON.stringify(params));\n    }\n    return ret.rawData;\n  }\n  _lookUpInMap(params) {\n    let ret;\n    const m = this._m;\n    const { key, id } = params;\n    const newId = this._getId(key, id);\n    if (this.enableCache && this.cache[newId]) {\n      ret = this.cache[newId];\n      return this._loadMapItem({ ret, ...params });\n    }\n    if (m[newId] !== undefined) {\n      return this.getItem('map_' + m[newId]).then(ret => this._loadMapItem({ ret, ...params }));\n    }\n    return this._noItemFound({ ret, ...params });\n  }\n  remove(params) {\n    return this._mapPromise.then(() => {\n      let m = this._m;\n      let { key, id } = params;\n\n      if (id === undefined) {\n        if (this.enableCache && this.cache[key]) {\n          delete this.cache[key];\n        }\n        return this.removeItem(key);\n      }\n      let newId = this._getId(key, id);\n\n      // remove existing data\n      if (m[newId] !== undefined) {\n        if (this.enableCache && this.cache[newId]) {\n          delete this.cache[newId];\n        }\n        this._removeIdInKey(key, id);\n        let idTobeDeleted = m[newId];\n        delete m[newId];\n        this.setItem('map', JSON.stringify(m));\n        return this.removeItem('map_' + idTobeDeleted);\n      }\n    });\n  }\n  _removeIdInKey(key, id) {\n    const indexTobeRemoved = (this._m.__keys__[key] || []).indexOf(id);\n    if (indexTobeRemoved !== -1) {\n      this._m.__keys__[key].splice(indexTobeRemoved, 1);\n    }\n  }\n  load(params) {\n    const { key, id, autoSync = true, syncInBackground = true, syncParams, batched } = params;\n    return this._mapPromise.then(() => {\n      if (id === undefined) {\n        return this._lookupGlobalItem({\n          key,\n          autoSync,\n          syncInBackground,\n          syncParams,\n        });\n      } else {\n        return this._lookUpInMap({\n          key,\n          id,\n          autoSync,\n          syncInBackground,\n          batched,\n          syncParams,\n        });\n      }\n    });\n  }\n  clearAll() {\n    this._s.clear && this._s.clear();\n    this._m = this._initMap();\n  }\n  clearMap() {\n    return this.removeItem('map').then(() => {\n      this.cache = {};\n      this._m = this._initMap();\n    });\n  }\n  clearMapForKey(key) {\n    return this._mapPromise.then(() => {\n      let tasks = (this._m.__keys__[key] || []).map(id => this.remove({ key, id }));\n      return Promise.all(tasks);\n    });\n  }\n  getIdsForKey(key) {\n    return this._mapPromise.then(() => {\n      return this._m.__keys__[key] || [];\n    });\n  }\n  getAllDataForKey(key, options) {\n    options = Object.assign({ syncInBackground: true }, options);\n    return this.getIdsForKey(key).then(ids => {\n      const querys = ids.map(id => ({ key, id, syncInBackground: options.syncInBackground }));\n      return this.getBatchData(querys);\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}